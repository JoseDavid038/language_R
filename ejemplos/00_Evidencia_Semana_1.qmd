---
title: "Evidencia Semana 1"
date: 2024-09-23
author: 
  - Camilo Andres Bohorquez Montenegro   
format: 
  html:
    toc: true
    toc-depth: 2
    code-fold: true
    number-sections: true
    embed-resources: true
editor: visual
---

```{r}
#| label: libraries
#| echo: false
#| message: false
library(readxl)
```

# Introducción

## Qué es R y para qué es usado?

R es un lenguaje de programación y entorno computacional dedicado a la estadística.

Decimos que es un lenguaje de programación porque nos permite dar instrucciones, usando código, a nuestros equipos de cómputo para que realicen tareas específicas (además de que es Turing Completo, pero profundizaremos en ello); para ello sólo necesitamos un intérprete para este código y es a esto a lo que llamamos un entorno computacional.

Cuando instalamos R en nuestra computadora en realidad lo que estamos instalando es el entorno computacional, y para que podamos hacer algo en ese entorno necesitamos conocer la manera de escribir instrucciones que el software pueda interpretar y ejecutar. Eso es lo que aprenderemos a hacer en este curso.

R es diferente a otros lenguajes de programación que por lo general están diseñados para realizar muchas tareas diferentes; esto es porque fue creado con el único propósito de hacer estadística. Esta característica es la razón de que R sea un lenguaje de programación peculiar, que puede resultar absurdo en algunos sentidos para personas con experiencia en otros lenguajes, pero también es la razón por la que R es una herramienta muy poderosa para el trabajo en estadística, puesto que funciona de la manera que una persona especializada en esta disciplina desearía que lo hiciera.

# Conceptos básicos

## La consola de R

Lo primero que nos encontramos al ejecutar R es una pantalla que nos muestra la versión de este lenguaje que estamos ejecutando y un prompt:

Esta es la consola de R y corresponde al entorno computacional de este lenguaje. Es aquí donde nuestro código es interpretado.

Podemos escribir código directamente en la consola y R nos dará el resultado de lo que pidamos allí mismo. Esta es la razón por la que se dice que R permite el uso interactivo, pues no es necesario compilar nuestro código para ver sus resultados.

## Ejecutar, llamar, correr y devolver

Cuando hablamos de ejecutar, llamar o correr nos referimos a pedir que R realice algo, en otras palabras, estamos dando una instrucción o una entrada.

Cuando decimos que R nos devuelve algo, es que ha realizado algo que le hemos pedido, es decir, nos está dando una salida.

Por ejemplo, si escribimos los siguiente en la consola lo siguiente y damos Enter, estamos pidiendo que se ejecute esta operación: \> 1 + 1

Y nos será devuelto su resultado: \[1\] 2

```{r}
1+1
```

## Objetos

En R, todo es un objeto. Todos los datos y estructuras de datos son objetos. Además, todos los objetos tienen un nombre para identificarlos.

La explicación de esto es un tanto compleja y se sale del alcance de este libro. Se relaciona con el paradigma de programación orientada a objetos y ese es todo un tema en sí mismo.

Lo importante es que recuerdes que al hablar de un objeto, estamos hablando de cualquier cosa que existe en R y que tiene un nombre.

## Constantes y variables

De manera análoga al uso de estos términos en lenguaje matemático, una constante es un objeto cuyo valor no podemos cambiar, en contraste, una variable es un objeto que puede cambiar de valor.

Por ejemplo, en la siguiente expresión,π y 2 son constantes, mientras que a y r son variables.

a=πr2

Las constantes y variables en R tienen nombres que nos permiten hacer referencia a ellas en operaciones.

Las constantes ya están establecidas por R, mientras que nosotros podemos crear variables, asignándoles valores a nombres.

En R usamos \<- para hacer asignaciones. De este modo, podemos asignar el valor 3 a la variable radio

```{r}
radio <- 3
radio
```

Es recomendable que al crear una variable usemos **nombres claros, no ambiguos y descriptivos**. Esto previene confusión y hace que nuestro código sea más fácil de comprender por otras personas o por nosotros mismos en el futuro.

Los nombres de las variables pueden incluir letras, números, puntos y guiones bajos. Deben empezar siempre con una letra o un punto y si empiezan con un punto, a este no puede seguirle un número.

Finalmente, cuando te encuentres con un renglón de código que inicia con un gato (hashtag), esto representa un comentario, es código que no se ejecutará, sólo se mostrará.

```{r}
# Este es un comentario
```

## Funciones

Una función es **una serie de operaciones a la que les hemos asignados un nombre**. Las funciones aceptan **argumentos**, es decir, especificaciones sobre cómo deben funcionar.

Cuando llamamos una función, se realizan las operaciones que contiene, usando los argumentos que hemos establecido.

En R reconocemos a una función usando la notación: `nombre_de_la_función()`. Por ejemplo:

-   `mean()`

-   `quantile()`

-   `summary()`

-   `density()`

-   `c()`

```{r}
mean(3,4,5,6,7,8,3,4,5,6)
quantile(x = 34.3545)
summary(2)
density(3,4)
c(3,4,5,6)
```

Al igual que con las variables, se recomienda que los nombres de las funciones sean claros, no ambiguos y descriptivos. Idealmente, el nombre de una función describe lo que hace. De hecho, es probable que adivines qué hacen casi todas funciones de la lista de arriba a partir de su nombre.

## Documentación

Las funciones de R *base* y aquellas que forman parte de paquete tienen un archivo de documentación.

Este archivo describe qué hace la función, sus argumentos, detalles sobre las operaciones que realiza,los resultados que devuelve y ejemplos de uso.

Para obtener la documentación de una función, escribimos el `?` antes de su nombre y lo ejecutamos. También podemos usar la función `help()`, con el nombre de la función.

Los dos procedimientos siguientes son equivalentes.

```{r}
?mean()
help("mean")
```

Si usas RStudio, la documentación de la función se mostrará en uno de los paneles de este IDE. Si estas usando R directamente, se abrirá una ventana de tu navegador de internet.

También podemos obtener la documentación de un paquete, si damos el argumento `package` a la función `help()`, con el nombre de un paquete.

Por ejemplo, la documentación del paquete **stats**, instalado por defecto en R *base*.

```{r}
help(package = "stats")
```

## Directorio de trabajo

El directorio o carpeta de trabajo es el lugar en nuestra computadora en el que se encuentran los archivos con los que estamos trabajando en R. Este es el lugar donde R buscara archivos para importarlos y al que serán exportados, a menos que indiquemos otra cosa.

Puedes encontrar cuál es tu directorio de trabajo con la función `getwd()`. Sólo tienes que escribir la función en la consola y ejecutarla.

```{r}
getwd()
```

Se mostrará en la consola la ruta del directorio que está usando R.

Puedes cambiar el directorio de trabajo usando la función `setwd()`, dando como argumento la ruta del directorio que quieres usar.

```{r}
#setwd(C\otro_directorio) 
```

Por último, si deseas conocer el contenido de tu directorio de trabajo, puedes ejecutar. la función `list.files()`, sin argumentos, que devolverá una lista con el nombre de los archivos de tu directorio de trabajo. La función `list.dirs()`, también sin argumentos\` te dará una lista de los directorios dentro del directorio de trabajo.

```{r}
#Ver archivos
list.files()
#Ver directorios
list.dirs()
```

### Sesión

Los objetos y funciones de R son almacenados en la memoria RAM de nuestra computadora.

Cuando ejecutamos R, ya sea directamente o a través de RStudio, estamos creando una instancia del entorno del entorno computacional de este lenguaje de programación. **cada instancia es una sesión**.

Todos los objetos y funciones creadas en una sesión, permanecen sólo en ella, no son compartidos entre sesiones, sin embargo una sesión puede tener el mismo directorio de trabajo que otra sesión.

Es posible tener más de una sesión de R activa en la misma computadora. Aunque ambas

Cuando cerramos R, también cerramos nuestra sesión. Se nos preguntará si deseamos guardar el contenido de nuestra sesión para poder volver a ella después. Esto se guarda en un archivo con extensión \*\*.Rdata\* en tu directorio de trabajo.

Para conocer los objetos y funciones que contiene nuestra sesión, usamos la función `ls()`, que nos devolverá una lista con los nombres de todo lo guardado en la sesión.

```{r}
ls()
```

De manera más precisa, nuestra sesión es un **entorno** de trabajo y los objetos pertenecen a un entorno específico.

##Paquetes

R puede ser expandido con **paquetes**. Cada paquete es una colección de funciones diseñadas para atender una tarea específica. Por ejemplo, hay paquetes para trabajo visualización geoespacial, análisis psicométricos, mineria de datos, interacción con servicios de internet y muchas otras cosas más.

Estos paquetes se encuentran alojados en **CRAN**, así que pasan por un control riguroso antes de estar disponibles para su uso generalizado.

Podemos instalar paquetes usando la función `install.packages()`, dando como argumento el nombre del paquete que deseamos instalar, entre comillas.

Por ejemplo, para instalar el paquete **readr**, corremos lo siguiente.

```{r}
install.packages("readr", repos = "https://cran.rstudio.com/")
```

Hecho esto, apareceran algunos mensajes en la consola mostrando el avance de la instalación

Una vez concluida la instalación de un paquete, podrás usar sus funciones con la función library(). Sólo tienes que llamar esta función usando como argument oel nombre del paquete que quieres utilizar

```{r}
library(readr)
```

Cuando haces esto, R importa las funciones contenidas en el paquete al entorno de trabajo actual.

Es importante que tengas en mente que debes hacer una llamada a library() cada que inicies una sesión en R. Aunque hayas importado las funciones de un paquete con anterioridad, las sesiones de R se inician “limpias”, sólo con los objetos y funciones de base.

Este comportamiento es para evitar problemas de compatibilidad y para propiciar buenas prácticas de colaboración.

Si importamos paquetes automáticamente y usamos sus funciones sin indicar de donde provienen, al compartir nuestro código con otras personas, estas no tendrán la información completa para entender qué estamos haciendo. R, al pedirnos que cada sesión indiquemos qué estamos importando, nos obliga a ser explícito con todo lo que estamos haciendo. Es un poco latoso, pero te acostumbras a ello.

En caso de escribir en install.packages() el nombre de un paquete no disponible en CRAN, se nos mostrará una advertencia y no se instalará nada.

```{r}
#install.packages("un_paquete_falso")
```

Los paquetes que hemos importado en nuestra sesión actual aparecen al llamar sessionInfo().

También podemos ver qué paquetes tenemos ya instalados ejecutando la función installed.packages() sin ningún argumento. Una instalación nueva de R tiene pocos paquetes instalados, pero esta lista puede crecer considerablemente con el tiempo.

## Scripts

Los scripts son documentos de texto con la extensión de archivo **.R**, por ejemplo `mi_script.R`.

Estos archivos son iguales a cualquier documentos de texto, pero R los puede leer y ejecutar el código que contienen.

Aunque R permite el uso interactivo, es recomendable que guardes tu código en un archivo .R, de esta manera puedes usarlo después y compartirlo con otras personas. En realidad, en proyectos complejos, es posible que sean necesarios mútiples scripts para distintos fines.

Podemos abrir y ejecutar scripts en R usando la función `source()`, dandole como argumento la ruta del archivo .R en nuestra computadora, entre comillas.

Por ejemplo.

```{r}
source("00_Evidencia_Semana_1_Script.R")
```

Cuando usamos RStudio y abrimos un script con extensión .R, este programa nos abre un panel en el cual podemos ver su contenido. De este modo podemos ejecutar todo el código que contiene o sólo partes de él.

# Tipos de datos

En R los datos pueden ser de diferentes tipos. Cada tipo tiene características particulares que lo distinguen de los demás. Entre otras cosas algunas operaciones sólo pueden realizarse con tipos de datos específicos

Revisaremos los tipos de datos más comunes en R y sus propiedades, así como la coerción entre tipos de dato.

## Datos más comunes

Los tipos de datos de uso más común en R son los siguientes:

```{r}
Datos_mas_comunes_tabla <- read_excel("Datos_mas_comunes_tabla.xlsx")
head(Datos_mas_comunes_tabla)
```

Además de estos tipos, en R también contamos con datos complejos numéricos complejos (con una parte real y una imaginaria), **raw** (bytes), fechas y *raster*, entre otros. Estos tipos tiene aplicaciones muy específicas, por ejemplo, los datos de tipo fecha son ampliamente usados en economía, para análisis de series de tiempo.

Revisemos las principales características de estos tipos de dato.

## Entero y numérico

Como su nombre lo indica, los datos enteros representan números enteros, sin una parte decimal o fraccionaria, que pueden ser usados en operaciones matemáticas.

Por su parte, como su nombre lo indica, los datos numéricos representan números, la diferencia de estos con los datos enteros es que tiene una parte decimal o fraccionaria.

Los datos numéricos también son llamados *doble* o *float* (flotantes). Este nombre se debe a que, en realidad, son números de doble precisión, pues tienen una parte entera y una fraccionaria decimal, y son llamados *float* debido a que se usa un punto flotante para su representación computacional.

Para fines prácticos, estos términos son sinónimos, siempre que hablemos de datos numéricos, nos referimos a este tipo.

## Cadena de texto

El tipo *character* representa texto y es fácil reconocerlo porque un dato siempre esta rodeado de comillas, simples o dobles. De manera convencional, nos referimos a este tipo de datos como cadenas de texto, es decir, secuencias de caracteres.

Este es el tipo de datos más flexible de R, pues una cadena de texto puede contener letras, números, espacios, signos de puntuación y símbolos especiales.

## Factor

Un factor es un tipo de datos específico a R. Puede ser descrito como un dato numérico representado por una etiqueta.

Supongamos que tenemos un conjunto de datos que representan el sexo de personas encuestadas por teléfono, pero estos se encuentran capturados con los números 1 y 2. El número 1 corresponde a **femenino** y el 2 a **masculino**.

En R, podemos indicar que se nos muestre, en la consola y para otros análisis, los 1 como `femenino` y los 2 como `masculino`. Aunque para nuestra computadora, `femenino` tiene un valor de 1, pero a nosotros se nos muestra la palabra `femenino`. De esta manera reducimos el espacio de almacenamiento necesario para nuestros datos.

Este comportamiento es similar a lo que ocurre con paquetes estadísticos comerciales como *SPSS Statistics*, en los que podemos asignar etiquetas a los datos, dependiendo de su valor. La diferencia se encuentra en que R trata a los factores de manera diferente a un dato numérico.

Por último, cada una de las etiquetas o valores que puedes asumir un factor se conoce como **nivel**. En nuestro ejemplo con `femenino` y `masculino`, tendríamos dos niveles.

Ejemplo:

```{r}
#crear un vector de genero como factor
generos <- factor(c(1,2), labels = c("femenino","masculino"))
# imprimir el factor 
print(generos)
```

## Lógico

Los datos de tipo lógico sólo tienen dos valores posibles: verdadero (`TRUE`) y falso (`FALSE`). Representan si una condición o estado se cumple, es verdadero, o no, es falso.

Este tipo de dato es, generalmente, el resultado de operaciones relacionales y lógicas, son esenciales para trabajar con **álgebra Booleana**, lo cual revisaremos en el (capítulo 5)(#-operadores).

Como este tipo de dato sólo admite dos valores específicos, es el más restrictivo de R.

## `NA` y `NULL`

En R, usamos `NA` para representar datos perdidos, mientras que `NULL` representa la ausencia de datos.

La diferencia entre las dos es que un dato `NULL` aparece sólo cuando R intenta recuperar un dato y no encuentra nada, mientras que `NA` es usado para representar explícitamente datos perdidos, omitidos o que por alguna razón son faltantes.

Por ejemplo, si tratamos de recuperar la edad de una persona encuestada que no existe, obtendríamos un `NULL`, pues no hay ningún dato que corresponda con ello. En cambio, si tratamos de recuperar su estado civil, y la persona encuestada no contestó esta pregunta, obtendríamos un `NA`.

`NA` además puede aparecer como resultado de una operación realizada, pero no tuvo éxito en su ejecución.

## Coerción

En R, los datos pueden ser coercionados, es decir, forzados, para transformarlos de un tipo a otro.

La coerción es muy importante. Cuando pedimos a R ejecutar una operación, intentará coercionar de manera **implícita**, sin avisarnos, los datos de su tipo original al tipo correcto que permita realizarla. Habrá ocasiones en las que R tenga éxito y la operación ocurra sin problemas, y otras en las que falle y obtengamos un error.

Lo anterior ocurre porque no todos los tipos de datos pueden ser transformados a los demás, para ello se sigue una regla general.

**La coerción de tipos se realiza de los tipos de datos más restrictivos a los más flexibles.**

Las coerciones ocurren en el siguiente orden.

`lógico -> entero -> numérico -> cadena de texto` (`logical -> integer -> numeric -> character`)

Las coerciones no pueden ocurrir en orden inverso. Podemos coercionar un dato de tipo entero a uno numérico, pero uno de cadena de texto a numérico.

Como los datos de tipo lógico sólo admiten dos valores (`TRUE` y `FALSE`), estos son los más restrictivos; mientras que los datos de cadena de texto, al admitir cualquier cantidad y combinación de caracteres, son los más flexibles.

Los factores son un caso particular para la coerción. Dado que son valores numéricos con etiquetas, pueden ser coercionados a tipo numérico y cadena de texto; y los datos numéricos y cadena de texto pueden ser coercionados a factor. Sin embargo, al coercionar un factor tipo numérico, perdemos sus niveles.

### Coerción explícita con la familia `as()`

También podemos hacer coerciones **explícitas** usando la familia de funciones `as()`.

```{r}
Coercio_n_expli_cita_con_la_familia_as_tabla <- read_excel("Coerción explícita con la familia as() tabla.xlsx")
print(Coercio_n_expli_cita_con_la_familia_as_tabla)
```

Cuando estas funciones tienen éxito en la coerción, nos devuelven datos del tipo pedido. Si fallan, obtenemos `NA` como resultado.

Por ejemplo, intememos convertir el número 5 a una cadena de texto. Para ello usamos la función `as.character()`.

```{r}
as.character(5)
```

Esta es una coerción válida, así que tenemos éxito. Pero, si intentamos convertir la palabra “cinco” a un dato numérico, obtendremos una advertencia y `NA`.

```{r}
as.numeric("cinco")
```

Comprobemos el comportamiento especial de los factores.

Podemos coercionar al número 5 y la palabra “cinco” en un factor.

```{r}
as.factor(5)
as.factor("cinco")
```

Asignamos la palabra “cinco” como factor al objeto `factor_cinco`.

```{r}
factor_cinco <- as.factor("cinco")
factor_cinco
```

Ahora podemos coercionar `factor_cinco` a cadena de texto y a numérico.

```{r}
as.character(factor_cinco)
as.numeric(factor_cinco)
```

Si coercionamos un dato de tipo lógico a numérico, `TRUE` siempre devolverá 1 y `FALSE` dará como resultado 0.

```{r}
as.numeric(TRUE)
as.numeric(FALSE)
```

Por último, la funcón `as.null()` siempre devuelve `NULL`, sin importar el tipo de dato que demos como argumento.

```{r}
as.null(FALSE)
as.null(467)
as.null("palabra")
```

# Operadores

Los operadores son los símbolos que le indican a R que debe realizar una tarea. Combinando datos y operadores es que logramos que R haga su trabajo.

Existen operadores específicos para cada tipo de tarea. Los tipos de operadores principales son los siguientes:

-   Aritméticos

-   Relacionales

-   Lógicos

-   De asignación

Familiarizarnos con los operadores nos permitirá manipular y transformar datos de distintos tipos.

## Operadores aritméticos

Como su nombre lo indica, este tipo de operador es usado para operaciones aritméticas.

En R tenemos los siguientes operadores aritméticos:

```{r}
operadores_aritmeticos<- read_excel("Operadores_aritmeticos_tabla.xlsx")
print(operadores_aritmeticos)
```

Es posible realizar operaciones aritméticas con datos de tipo **entero** y **numérico**.

Si escribes una operación aritmética en la consola de R y das Enter, esta se realiza y se devuelve su resultado.

```{r}
5+3
1-1
5*5
10000/7
5^3
5%%3
4%%2
```

## Operadores relacionales

Los operadores lógicos son usados para hacer comparaciones y siempre devuelven como resultado `TRUE` o `FALSE` (verdadero o falso, respectivamente).

```{r}
operador_relacionales_tabla <- read_excel("Operadores_relacionales_tabla.xlsx")
print(operador_relacionales_tabla)
```

Es posible comparar cualquier tipo de dato sin que resulte en un error.

Sin embargo, al usar los operadores `>`, `>=`, `<` y `<=` con cadenas de texto, estos tienen un comportamiento especial.

Por ejemplo, `"casa" > "barco"` nos devuelve `TRUE`.

```{r}
"casa">"barco"
```

## Operadores lógicos

Los operadores lógicos son usados para operaciones de **álgebra Booleana**, es decir, para describir relaciones lógicas, expresadas como verdadero (`TRUE`) o falso (`FALSO`).

```{r}
Operadores_logicos_tabla <- read_excel("Operadores_logicos_tabla.xlsx", 
    sheet = "Hoja1")
print(Operadores_logicos_tabla)

```

Los operadores `|` y `&` siguen estas reglas:

-   `|` devuelve `TRUE` si alguno de los datos es `TRUE`

-   `&` solo devuelve `TRUE` si ambos datos es `TRUE`

-   `|` solo devuelve `FALSE` si ambos datos son `FALSE`

-   `&` devuelve `FALSE` si alguno de los datos es `FALSE`

Estos operadores pueden ser usados con estos con datos de tipo **numérico**, **lógico** y **complejo**. Al igual que con los operadores relacionales, los operadores lógicos siempre devuelven `TRUE` o `FALSE`.

Para realizar operaciones lógicas, todos los valores numéricos y complejos distintos a `0` son coercionados a `TRUE`, mientras que `0` siempre es coercionado a `FALSE`.

Por ejemplo, `5 | 0` resulta en `TRUE` y `5 & FALSE` resulta en `FALSE`. Podemos comprobar lo anterior con la función `isTRUE()`.

```{r}
5|0
5&0
isTRUE(0)
isTRUE(5)
```

Estos operadores se pueden combinar para expresar relaciones complejas.

Por ejemplo, la negación `FALSE` Y `FALSE` dará como resultado `TRUE`.

```{r}
!(FALSE|FALSE)
```

También podemos combinar operadores lógicos y relacionales, dado que esto últimos dan como resultado `TRUE` y `FALSE`.

```{r}
isTRUE(FALSE|TRUE)
```

## Operadores de asignación

Este es probablemente el operador más importante de todos, pues nos permite asignar datos a variables.

```{r}
Operadores_de_asignacio_n <- read_excel("Operadores de asignación.xlsx")
print(Operadores_de_asignacio_n)
```

Aunque podemos usar el signo igual para una asignación, a lo largo de este libro utilizaremos `<-`, por ser característico de R y fácil de reconocer visualmente.

Después de realizar la operación de asignación, podemos usar el nombre de la variable para realizar operaciones con ella, como si fuera del tipo de datos que le hemos asignado. Si asignamos un valor a una variable a la que ya habíamos asignado datos, nuestra variable conserva el valor más reciente.

Además, esta operación nos permite “guardar” el resultado de operaciones, de modo que podemos recuperarlos sin necesidad de realizar las operaciones otra vez. Basta con llamar el nombre de la variable en la consola

En este ejemplo, asignamos valores a las variables `estatura` y `peso`.

```{r}
estatura <- 1.71
peso <- 79
```

Llamamos a sus valores asignados

```{r}
estatura
peso
```

Usamos los valores asignados para realizar operaciones.

```{r}
peso/estatura^2
```

Cambiamos el valor de una variable a uno nuevo y realizamos operaciones

```{r}
peso <- 72
peso
peso/estatura^2
```

```{r}
estatura <- 1.56
peso <- 48
peso/estatura^2
```

Asignamos el resultado de una operación a una variable nueva.

```{r}
bmi <- peso/estatura^2
bmi
```

Como podrás ver, es posible asignar a una variable valores de otra variable o el resultado de operaciones con otras variables.

```{r}
velocidad_inicial <- 110
velocidad_final <- 185
tiempo_inicial <- 0
tiempo_final <- 15

variacion_velocidad <- velocidad_final - velocidad_inicial
variacion_tiempo <- velocidad_final - velocidad_inicial

variacion_velocidad / variacion_tiempo
```

## Orden de operaciones

En R, al igual que en matemáticas, las operaciones tienen un orden de evaluación definido.

Cuanto tenemos varias operaciones ocurriendo al mismo tiempo, en realidad, algunas de ellas son realizadas antes que otras y el resultado de ellas dependerá de este orden.

El orden de operaciones incluye a las aritméticas, relacionales, lógicas y de asignación.

En la tabla siguiente se presenta el orden en que ocurren las operaciones que hemos revisado en este capítulo.

```{r}
Orden_de_operaciones <- read_excel("Orden_de_operaciones.xlsx")
print(Orden_de_operaciones)
```

Si deseamos que una operación ocurra antes que otra, rompiendo este orden de evaluación, usamos paréntesis.

Podemos tener paréntesis anidados.

## Vectores

Un vector es la estructura de datos más sencilla en R. Un vector es una colección de uno o más datos del mismo tipo.

Todos los vectores tienen tres propiedades:

-   **Tipo**. Un vector tiene el mismo tipo que los datos que contiene. Si tenemos un vector que contiene datos de tipo numérico, el vector será también de tipo numérico. Los vectores son **atómicos**, pues sólo pueden contener datos de un sólo tipo, no es posible mezclar datos de tipos diferentes dentro de ellos.

-   **Largo**. Es el número de elementos que contiene un vector. El largo es la única **dimensión** que tiene esta estructura de datos.

-   **Atributos**. Los vectores pueden tener metadatos de muchos tipos, los cuales describen características de los datos que contienen. Todos ellos son incluidos en esta propiedad. En este libro no se usarán vectores con metadatos, por ser una propiedad con usos van más allá del alcance de este libro.

Cuando una estructura únicamente puede contener datos de un sólo tipo, como es el caso de los vectores, decimos que es **homogénea**, pero no implica que necesariamente sea **atómica**. Regresaremos sobre esto al hablar de matrices y arrays.

Como los vectores son la estructura de datos más sencilla de R, datos simples como el número **3**, son en realidad vectores. En este caso, un vector de tipo numérico y largo igual a 1.

```{r}
3
```

Verificamos que el **3** es un vector con la función `is.vector()`.

```{r}
is.vector(3)
```

Y usamos la función `length()` para conocer su largo.

```{r}
length(3)
```

Lo mismo ocurre con los demás tipos de datos, por ejemplo, con cadenas de texto y datos lógicos.

```{r}
is.vector("tres")
is.vector(TRUE)
```

### Creación de vectores

Creamos vectores usando la función `c()` (*combinar*).

Llamamos esta función y le damos como argumento los elementos que deseamos combinar en un vector, separados por comas.

```{r}
# Vector numérico
c(1,2,3,5,8,13)
# Vector de cadena de texto
c("arbol","casa","persona")
# Vector lógico
c("true","true","false","false","true")
```

Si deseamos agregar un elemento a un vector ya existente, podemos hacerlo combinando nuestro vector original con los elementos nuevos y asignando el resultado a nuestro vector original.

```{r}
mi_vector <- c(TRUE,FALSE,TRUE)
mi_vector <- c(mi_vector,FALSE)

mi_vector
```

Naturalmente, podemos crear vectores que son combinación de vectores.

```{r}
mi_vector_1 <- c(1,3,5)
mi_vector_2 <- c(2,4,6)

mi_vector_3 <- c(mi_vector_1,mi_vector_2)
mi_vector_3
```

Si intentamos combinar datos de diferentes tipos en un mismo vector, R realizará coerción automáticamente. El vector resultante será del tipo más flexible entre los datos que contenga, siguiendo las reglas de ***coerción***.

Creamos un vector numérico.

```{r}
mi_vector <- c(1,2,3)
class(mi_vector)
```

Si intentamos agregar un dato de tipo cadena de texto, nuestro vector ahora será de tipo cadena de texto.

```{r}
mi_vector_nuevo <- c(mi_vector,"a")
class(mi_vector_nuevo)
```

Como las cadenas de texto son el tipo de dato más flexible, siempre que creamos un vector que incluye un dato de este tipo, el resultado será un vector de texto.

```{r}
mi_vector_mezcla <- c(FALSE,2,"tercero",4.00)
class(mi_vector_mezcla)
```

Podemos crear vectores de secuencias numéricas usando `:`. De un lado de los dos puntos escribimos el número de inicio de la secuencia y del otro el final.

Por ejemplo, creamos una secuencia del 1 al 10.

```{r}
1:300
```

También podemos crear una secuencia del 10 al 1.

```{r}
300:1
```

Las secuencias creadas con `:` son consecutivas con incrementos o decrementos de 1. Estas secuencias pueden empezar con cualquier número, incluso si este es negativo o tiene cifras decimales

```{r}
# Número negativo
-30:10
-20:-12
# Número con cifras decimales
67.20:75
```

Si nuestro número de inicio tiene cifras decimales, estas serán respetadas al hacer los incrementos o decrementos de uno en uno. En contraste, si es nuestro número de final el que tiene cifras decimales, este será redondeado.

```{r}
# Se conservan los decimales del inicio
-2.48:2
56.007:50
# Se redondean los decimales del final
166:170.05
968:960.928
```

### Vectorización de operaciones

Existen algunas operaciones al aplicarlas a un vector, se aplican a cada uno de sus elementos. A este proceso le llamamos **vectorización**.

Las operaciones aritméticas y relacionales pueden vectorizarse. Si las aplicamos a un vector, la operación se realizará para cada uno de los elementos que contiene.

Por ejemplo, creamos un vector numérico.

```{r}
mi_vector <- c(2,3,6,7,8,10,11)
```

Si aplicamos operaciones aritméticas, obtenemos un vector con un resultado por cada elemento.

```{r}
# Operaciones aritméticas
mi_vector + 2
mi_vector * 2
mi_vector %% 2
```

Al aplicar operaciones relacionales, obtenemos un vector de `TRUE`y `FALSE`, uno para cada elemento comparado.

```{r}
mi_vector > 7
mi_vector < 7
mi_vector == 7
```

Esta manera de aplicar una operación es muy eficiente. Comparada con otros procedimientos, requiere de menos tiempo de cómputo, lo cual a veces es considerable, en particular cuando trabajamos con un número grande de datos.

Aunque el nombre de este proceso es **vectorización**, también funciona, en ciertas circunstancias, para otras estructuras de datos.

## Matrices y arrays

Las matrices y arrays pueden ser descritas como **vectores multidimensionales**. Al igual que un vector, únicamente pueden contener datos de un sólo tipo, pero además de largo, tienen más dimensiones.

En un sentido estricto, las matrices son una caso especial de un array, que se distingue por tener **específicamente dos dimensiones**, un “largo”" y un “alto”. Las matrices son, por lo tanto, una estructura con forma rectangular, con renglones y columnas.

Como las matrices son usadas de manera regular en matemáticas y estadística, es una estructura de datos de uso común en R común y en la que nos enfocaremos en este libro.

Los arrays, por su parte, pueden tener un número arbitrario de dimensiones. Pueden ser cubos, hipercubos y otras formas. Su uso no es muy común en R, aunque a veces es deseable contar con objetos n-dimensionales para manipular datos. Como los arrays tienen la restricción de que todos sus datos deben ser del mismo tipo, no importando en cuántas dimensiones se encuentren, esto limita sus usos prácticos.

En general, es preferible usar listas en lugar de arrays, una estructura de datos que además tienen ciertas ventajas que veremos más adelante.

### Creación de matrices

Creamos matrices en R con la función `matrix()`. La función `matrix()` acepta dos argumentos, `nrow` y `ncol`. Con ellos especificamos el número de renglones y columnas que tendrá nuestra matriz.

```{r}
# Un vector numérico del uno al doce
1:12
# matrix() sin especificar renglones ni columnas
matrix(1:12)
# Tres renglones y cuatro columnas
matrix(1:12, nrow = 3, ncol = 4)
# Cuatro columnas y tres columnas
matrix(1:12, nrow = 4, ncol = 3)
# Dos renglones y seis columnas
matrix(1:12, nrow = 2, ncol = 6)
```

Los datos que intentemos agrupar en una matriz serán acomodados en orden, de arriba a abajo, y de izquierda a derecha, hasta formar un rectángulo.

Si multiplicamos el número de renglones por el número de columnas, obtendremos el número de celdas de la matriz. En los ejemplo anteriores, el número de celdas es igual al número de elementos que queremos acomodar, así que la operación ocurre sin problemas.

Cuando intentamos acomodar un número diferente de elementos y celdas, ocurren dos cosas diferentes.

Si el número de elementos es mayor al número de celdas, se acomodarán todos los datos que sean posibles y los demás se omitirán.

```{r}
matrix(1:12, nrow = 3, ncol = 3)
```

Si, por el contrario, el número de celdas es mayor que el número de elementos, estos se **reciclaran**. En cuanto los elementos sean insuficientes para acomodarse en las celdas, R nos devolverá una advertencia y se empezaran a usar los elementos a partir del primero de ellos

```{r}
matrix(1:12, nrow = 5, ncol = 4)
```

Otro procedimiento para crear matrices es la unión vectores con las siguientes funciones:

-   `cbind()` para unir vectores, usando cada uno como una columna.

-   `rbind()` para unir vectores, usando cada uno como un renglón.

De este modo podemos crear cuatro vectores y unirlos para formar una matriz. Cada vector será un renglón en esta matriz.

Creamos cuatro vectores, cada uno de largo igual a cuatro.

```{r}
vector_1 <- 1:4
vector_2 <- 5:8
vector_3 <- 9:12
vector_4 <- 13:16
```

Usamos `rbind()` para crear un matriz, en la que cada vector será un renglón.

```{r}
matriz <- rbind(vector_1,vector_2,vector_3,vector_4)
# Resultado
matriz
```

Si utilizamos `cbind()`, entonces cada vector será una columna.

```{r}
matriz <- cbind(vector_1,vector_2,vector_3,vector_4)
# Resultado
matriz
```

Al igual que con `matrix()`, los elementos de los vectores son reciclados para formar una estructura rectangular y se nos muestra un mensaje de advertencia.

```{r}
# Elementos de largo diferente
vector_1 <- 1:2
vector_2 <- 1:3
vector_3 <- 1:5

matriz <- cbind(vector_1,vector_2,vector_3)

# Resultado
matriz
```

Finalmente, las matrices pueden contener `NA`s.

Creamos dos vectores con un `NA` en ellos.

```{r}
vector_1 <- c(NA,1,2)
vector_2 <- c(3,4,NA)
```

Creamos una matriz con `rbind()`.

```{r}
matriz <- rbind(vector_1,vector_2) 
# Resultados
matriz
```

Como `NA` representa datos perdidos, puede estar presente en compañía de todo tipo de de datos.

### Propiedades de las matrices

No obstante que las matrices y arrays son estructuras que sólo pueden contener un tipo de datos, no son atómicas. Su clase es igual a **matriz (matrix)** o **array** segun corresponda.

Verificamos esto usando la función `class()`.

```{r}
mi_matriz <- matrix(1:10)
class(mi_matriz)
```

Las matrices y arrays pueden tener más de una dimensión.

Obtenemos el número de dimensiones de una matriz o array con la función `dim()`. Esta función nos devolverá varios números, cada uno de ellos indica la cantidad de elementos que tiene una dimensión.

```{r}
mi_matriz <- matrix(1:12,nrow = 4, ncol = 3)
dim(mi_matriz)
```

Cabe señalar que si usamos `dim()` con un vector, obtenemos `NULL`. Esto ocurre con todos los objetos unidimensionales

```{r}
mi_vector <- 1:12
dim(mi_vector)
```

Finalmente, las operaciones aritméticas también son vectorizadas al aplicarlas a una matriz. La operación es aplicada a cada uno de los elementos de la matriz.

Creamos una matriz.

```{r}
mi_matriz <- matrix(1:9, nrow = 3, ncol = 3)

# Resultado 
mi_matriz
```

Intentemos sumar, multiplicar y elevar a la tercera potencia.

```{r}
# Suma
mi_matriz + 1
# Multiplicacion
mi_matriz * 2
# Pontenciacion
mi_matriz ^ 3
```

Si intentamos vectorizar una operación utilizando una matriz con `NA`s, esta se aplicará para los elementos válidos, devolviendo `NA` cuando corresponda.

Creamos una matriz con `NA`s.

```{r}
vector_1 <- c(NA, 2, 3)
vector_2 <- c(4, 5, NA)

matriz <- rbind(vector_1,vector_2)

# Resultado 
matriz
```

Intentamos dividir sus elementos entre dos.

```{r}
matriz / 2
```

Finalmente, podemos usar la función `t()` para transponer una matriz, es decir, rotarla 90°.

Creamos una matriz con tres renglones y dos columnas.

```{r}
matriz <- matrix(1:6, nrow = 3)

# Resultado 
matriz
```

Usamos `t()` para transponer.

```{r}
matriz_t <- t(matriz)

# Resultado 
matriz_t
```

Obtenemos una matriz con dos renglones y dos columnas.

## Data frames

Los data frames son estructuras de datos de dos dimensiones (rectangulares) que pueden contener datos de diferentes tipos, por lo tanto, son heterogéneas. Esta estructura de datos es la más usada para realizar análisis de datos y seguro te resultará familiar si has trabajado con otros paquetes estadísticos.

Podemos entender a los data frames como una versión más flexible de una matriz. Mientras que en una matriz todas las celdas deben contener datos del mismo tipo, los renglones de un data frame admiten datos de distintos tipos, pero sus columnas conservan la restricción de contener datos de un sólo tipo.

En términos generales, los renglones en un data frame representan casos, individuos u observaciones, mientras que las columnas representan atributos, rasgos o variables. Por ejemplo, así lucen los primeros cinco renglones del objeto **iris**, el famoso conjunto de datos *Iris de Ronald Fisher*, que está incluido en todas las instalaciones de R.

```         
##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
```

Los primeros cinco renglones corresponden a cinco casos, en este caso flores. Las columnas son variables con los rasgos de cada flor: largo y ancho de sépalo, largo y ancho de pétalo, y especie.

Para crear un data frame usamos la función `data.frame()`. Esta función nos pedirá un número de vectores igual al número de columnas que deseemos. Todos los vectores que proporcionemos deben tener el mismo largo.

Esto es muy importante: **Un data frame está compuesto por vectores**.

Más adelante se hará evidente porque esta característica de un data frame es sumamente importante y también, cómo podemos sacarle provecho.

Además, podemos asignar un nombre a cada vector, que se convertirá en el nombre de la columna. Como todos los nombres, es recomendable que este sea claro, no ambiguo y descriptivo.

```{r}
mi_df <- data.frame("entero" = 1:4,
                    "factor" = c("a","b","c","d"),
                    "numero" = c(1.2, 3.4, 4.5, 5.6),
                    "cadena" = as.character(c("a","b","c","d")))

mi_df
```

```{r}
# Podemos usar dim() en un data frame
dim(mi_df)
# El largo de un data frame es igual a su número de columnas
length(mi_df)
# names() nos permite ver los nombres de las columnas
names(mi_df)
# La clase de un data frame es data.frame
class(data.frame)
```

Si los vectores que usamos para construir el data frame no son del mismo largo, los datos **no se reciclaran**. Se nos devolverá un error.

```{r}
#data.frame(
 # "entero" = 1:3, 
  #"factor" = c("a", "b", "c", "d"), 
  #"numero" = c(1.2, 3.4, 4.5, 5.6),
  #"cadena" = as.character(c("a", "b", "c", "d"))
#)
```

También podemos coercionar esta matriz a un data frame.

Creamos una matriz.

```{r}
matriz <- matrix(1:12, ncol = 4)

```

Usamos `as.data.frame()` para coercionar una matriz a un data frame.

```{r}
df <- as.data.frame(matriz)
# Verificamos Resultado 
class(df)

# Resultado 
df
```

### Propiedades de un data frame

Al igual que con una matriz, si aplicamos una operación aritmética a un data frame, esta se vectorizará.

Los resultados que obtendremos dependerán del tipo de datos de cada columna. R nos devolverá todas las advertencias que ocurran como resultado de las operaciones realizadas, por ejemplo, aquellas que hayan requerido una coerción.

```{r}
mi_df <- data.frame("entero" = 1:4,
                    "factor" = c("a","b","c","d"),
                    "numero" = c(1.2,3.4,4.5,5.6),
                    "cadena" = as.character(c("a","b","c","d")))

df * 2
```
